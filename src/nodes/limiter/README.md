# Limiter (Rust + WASM + AudioWorklet) reference module

This node is a minimal template for writing DSP in Rust, compiling it to WebAssembly, and running it on the Web Audio rendering thread via `AudioWorkletProcessor`.

## How it plugs into the engine

- The editor/graph system discovers node modules from `src/nodes/index.ts`.
- Each module provides:
  - UI + state schema (`graph.tsx`, `types.ts`)
  - audio runtime (`audio.ts`)
  - (optional) worklet module URLs (`workletModules` in `index.ts`)
- The engine preloads any declared worklet modules before starting audio:
  - `src/audio/engine.ts` calls `listBuiltInAudioWorkletModules()` and `audioContext.audioWorklet.addModule(url)`.

## Files and responsibilities

- `index.ts`
  - Exports `limiterNode` and declares `workletModules: ["./processor.ts?worklet"]` so the engine preloads the processor code.
- `audio.ts`
  - Creates the `AudioWorkletNode` (`new AudioWorkletNode(ctx, "limiter", ...)`).
  - Loads `limiter.wasm` via Vite asset import (`import limiterWasmUrl from "./limiter.wasm?url"`) and passes `processorOptions.wasmBytes` so the processor can instantiate WASM without fetching.
  - Calls `worklet.port.postMessage({ type: "params", params: ... })` from `updateState(...)`.
- `processor.ts`
  - Runs on the audio rendering thread as an `AudioWorkletProcessor` registered via `registerProcessor("limiter", ...)`.
  - Instantiates the WASM module from `processorOptions.wasmBytes`.
  - Copies audio blocks into WASM memory (interleaved), calls `limiter_process_interleaved(...)`, then copies results back.
- `dsp/` (Rust)
  - `dsp/src/lib.rs` exports a tiny C-ABI suitable for calling from the worklet:
    - `limiter_new(sample_rate_hz) -> ptr`
    - `limiter_set_params(ptr, ...)`
    - `limiter_process_interleaved(ptr, in_ptr, out_ptr, frames, channels)`
    - `limiter_free(ptr)`
    - `wasm_alloc(bytes)` / `wasm_free(ptr, bytes)` for buffer management
- `limiter.wasm`
  - Built artifact (not committed) generated by `build-wasm.sh`.
  - Imported by Vite as an asset URL and loaded as an `ArrayBuffer` in `audio.ts`.

## Building the WASM

From the repo root:

- `npm run build-wasm`

This runs the repo-level build orchestrator `scripts/build-wasm.mjs`, which scans `src/nodes/*/` for:
- `build-wasm.mjs` (Node-based build step), or
- `build-wasm.sh` (shell-based build step)

For this node, it finds and runs `src/nodes/limiter/build-wasm.sh`, which:
- builds `dsp/` for `wasm32-unknown-unknown` in release mode
- copies the `.wasm` to `src/nodes/limiter/limiter.wasm` (gitignored)

### Toolchain notes

You need rustup + the target installed:
- `rustup target add wasm32-unknown-unknown`

If you want to temporarily skip building WASM during `npm run dev`:
- `SKIP_WASM=1 npm run dev`

## RT-safety constraints (practical)

- Avoid allocations in `AudioWorkletProcessor.process()`:
  - allocate any WASM buffers outside `process()` (this module preallocates once on WASM init).
- Avoid async work in `process()`:
  - WASM instantiation happens async, but only during initialization; until ready the processor passes input through.
- Keep messages small and infrequent:
  - state updates are sent via `port.postMessage` (control-rate), not per-sample.

## Reusing this pattern for other nodes

Copy this directory and replace:
- `dsp/` exports with your DSP API
- the worklet `processor.ts` block processing glue
- the UI/state in `graph.tsx` + `types.ts`

Keep the integration points the same:
- export `workletModules` from the moduleâ€™s `index.ts`
- pass `processorOptions.wasmBytes` from `audio.ts`
